<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Algorithmic Thinking Process</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .graph-container {
            position: relative;
            width: 100%;
            height: 1000px;
            overflow: auto;
            border: 2px solid #3498db;
            border-radius: 15px;
            background: linear-gradient(45deg, #f8f9fa 25%, transparent 25%), 
                        linear-gradient(-45deg, #f8f9fa 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #f8f9fa 75%), 
                        linear-gradient(-45deg, transparent 75%, #f8f9fa 75%);
            background-size: 30px 30px;
            background-position: 0 0, 0 15px, 15px -15px, -15px 0px;
        }
        
        .node {
            position: absolute;
            padding: 10px 16px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            min-width: 120px;
            max-width: 160px;
            line-height: 1.2;
        }
        
        .node:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }
        
        .start { background: linear-gradient(135deg, #ff6b95, #ff8a9b); color: white; }
        .analysis { background: linear-gradient(135deg, #4facfe, #00f2fe); color: white; }
        .pattern { background: linear-gradient(135deg, #43e97b, #38f9d7); color: white; }
        .solution { background: linear-gradient(135deg, #fa709a, #fee140); color: white; }
        .advanced { background: linear-gradient(135deg, #667eea, #764ba2); color: white; }
        .implementation { background: linear-gradient(135deg, #a8edea, #fed6e3); color: #2c3e50; }
        .decision { background: linear-gradient(135deg, #ffecd2, #fcb69f); color: #2c3e50; }
        .example { background: linear-gradient(135deg, #c471ed, #f64f59); color: white; font-size: 10px; }
        
        .edge {
            position: absolute;
            background: #34495e;
            transform-origin: left center;
            height: 2px;
            border-radius: 2px;
            opacity: 0.6;
            transition: all 0.3s ease;
        }
        
        .edge:hover {
            height: 4px;
            opacity: 1;
            background: #e74c3c;
        }
        
        .edge-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 9px;
            font-weight: 600;
            color: #2c3e50;
            border: 1px solid #bdc3c7;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }
        
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
        }
        
        .path-highlight {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; transform: scale(1.02); }
            100% { opacity: 0.8; }
        }
        
        .controls {
            margin-bottom: 20px;
            text-align: center;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß† Complete Senior-Level Algorithmic Decision Tree</h1>
        
        <div class="controls">
            <button class="btn" onclick="highlightPath('knapsack')">Knapsack Path</button>
            <button class="btn" onclick="highlightPath('kadane')">Kadane's Path</button>
            <button class="btn" onclick="highlightPath('twopointer')">Two Pointer</button>
            <button class="btn" onclick="highlightPath('backtrack')">Backtracking</button>
            <button class="btn" onclick="highlightPath('unionfind')">Union-Find</button>
            <button class="btn" onclick="highlightPath('trie')">Trie/Prefix</button>
            <button class="btn" onclick="highlightPath('heap')">Heap</button>
            <button class="btn" onclick="highlightPath('binarysearch')">Binary Search</button>
            <button class="btn" onclick="clearHighlights()">Clear All</button>
        </div>
        
        <div class="graph-container" id="graph">
            <!-- Nodes will be dynamically positioned -->
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color start"></div>
                <span>Problem Start</span>
            </div>
            <div class="legend-item">
                <div class="legend-color analysis"></div>
                <span>Analysis Phase</span>
            </div>
            <div class="legend-item">
                <div class="legend-color decision"></div>
                <span>Decision Point</span>
            </div>
            <div class="legend-item">
                <div class="legend-color pattern"></div>
                <span>Pattern Recognition</span>
            </div>
            <div class="legend-item">
                <div class="legend-color solution"></div>
                <span>Core Algorithm</span>
            </div>
            <div class="legend-item">
                <div class="legend-color advanced"></div>
                <span>Advanced Pattern</span>
            </div>
            <div class="legend-item">
                <div class="legend-color example"></div>
                <span>Real Problems</span>
            </div>
        </div>
    </div>

    <script>
        const nodes = [
            // Start
            {id: 'start', text: 'üìã Problem Statement', x: 750, y: 50, class: 'start'},
            
            // First Analysis Layer
            {id: 'read', text: 'üëÄ Read & Understand', x: 750, y: 120, class: 'analysis'},
            {id: 'constraints', text: 'üìè Constraints Analysis', x: 350, y: 180, class: 'analysis'},
            {id: 'examples', text: 'üîç Trace Examples', x: 550, y: 180, class: 'analysis'},
            {id: 'output', text: 'üéØ Output Type?', x: 750, y: 180, class: 'analysis'},
            {id: 'complexity', text: '‚è∞ Expected Complexity?', x: 950, y: 180, class: 'analysis'},
            {id: 'data_size', text: 'üìä Data Scale?', x: 1150, y: 180, class: 'analysis'},
            
            // Core Decision Points
            {id: 'optimization', text: '‚ö° Optimization?\nMax/Min/Count?', x: 200, y: 250, class: 'decision'},
            {id: 'search_space', text: 'üîé Search Space?\nFind/Exists?', x: 400, y: 250, class: 'decision'},
            {id: 'data_structure', text: 'üìö Data Structure?\nArray/Tree/Graph?', x: 600, y: 250, class: 'decision'},
            {id: 'string_processing', text: 'üìù String Processing?\nPattern/Match?', x: 800, y: 250, class: 'decision'},
            {id: 'math_logic', text: 'üßÆ Math/Logic?\nNumber Theory?', x: 1000, y: 250, class: 'decision'},
            {id: 'interactive', text: 'üéØ Interactive?\nDesign/Stream?', x: 1200, y: 250, class: 'decision'},
            
            // Pattern Recognition Layer
            {id: 'subarray_pattern', text: 'üìä Subarray/Substring?\nContiguous Elements?', x: 100, y: 320, class: 'pattern'},
            {id: 'knapsack_pattern', text: 'üéí Items + Constraints?\nBinary Choices?', x: 250, y: 320, class: 'pattern'},
            {id: 'backtrack_pattern', text: 'üîÑ Generate All?\nConstraint Satisfaction?', x: 400, y: 320, class: 'pattern'},
            {id: 'dp_pattern', text: 'üß© Overlapping Subproblems?\nOptimal Substructure?', x: 550, y: 320, class: 'pattern'},
            {id: 'graph_pattern', text: 'üï∏Ô∏è Nodes + Edges?\nConnectivity?', x: 700, y: 320, class: 'pattern'},
            {id: 'trie_pattern', text: 'üå≥ Prefix/Dictionary?\nString Hierarchy?', x: 850, y: 320, class: 'pattern'},
            {id: 'heap_pattern', text: '‚õ∞Ô∏è Priority/Ordering?\nK-th Element?', x: 1000, y: 320, class: 'pattern'},
            {id: 'sorted_pattern', text: 'üìà Sorted/Monotonic?\nBinary Search?', x: 1150, y: 320, class: 'pattern'},
            {id: 'union_find_pattern', text: 'üîó Disjoint Sets?\nConnected Components?', x: 1300, y: 320, class: 'pattern'},
            
            // Core Algorithms
            {id: 'kadane', text: 'üìà Kadane\'s Algorithm', x: 50, y: 390, class: 'solution'},
            {id: 'sliding_window', text: 'ü™ü Sliding Window', x: 150, y: 390, class: 'solution'},
            {id: 'knapsack_dp', text: 'üéí Knapsack DP', x: 250, y: 390, class: 'solution'},
            {id: 'backtracking', text: 'üîÑ Backtracking', x: 350, y: 390, class: 'solution'},
            {id: 'classic_dp', text: 'üíé Classic DP', x: 450, y: 390, class: 'solution'},
            {id: 'dfs_bfs', text: 'üå≥ DFS/BFS', x: 550, y: 390, class: 'solution'},
            {id: 'dijkstra', text: 'üõ§Ô∏è Dijkstra/A*', x: 650, y: 390, class: 'solution'},
            {id: 'trie_ds', text: 'üå≥ Trie Data Structure', x: 750, y: 390, class: 'solution'},
            {id: 'kmp_algo', text: 'üîç KMP/Rabin-Karp', x: 850, y: 390, class: 'solution'},
            {id: 'heap_ops', text: '‚õ∞Ô∏è Heap Operations', x: 950, y: 390, class: 'solution'},
            {id: 'binary_search', text: 'üîç Binary Search', x: 1050, y: 390, class: 'solution'},
            {id: 'two_pointer', text: 'üëÜ Two Pointers', x: 1150, y: 390, class: 'solution'},
            {id: 'union_find', text: 'üîó Union-Find', x: 1250, y: 390, class: 'solution'},
            
            // Advanced Techniques
            {id: 'segment_tree', text: 'üå≤ Segment Tree\nRange Queries', x: 100, y: 460, class: 'advanced'},
            {id: 'fenwick_tree', text: 'üå≤ Fenwick Tree\nBIT', x: 200, y: 460, class: 'advanced'},
            {id: 'mo_algorithm', text: 'üîÑ Mo\'s Algorithm\nSqrt Decomposition', x: 300, y: 460, class: 'advanced'},
            {id: 'lca', text: 'üå≥ LCA\nBinary Lifting', x: 400, y: 460, class: 'advanced'},
            {id: 'topological_sort', text: 'üìä Topological Sort\nDAG Processing', x: 500, y: 460, class: 'advanced'},
            {id: 'strongly_connected', text: 'üîó Strongly Connected\nTarjan/Kosaraju', x: 600, y: 460, class: 'advanced'},
            {id: 'suffix_array', text: 'üìù Suffix Array/Tree\nString Advanced', x: 700, y: 460, class: 'advanced'},
            {id: 'convex_hull', text: 'üìê Convex Hull\nGeometry', x: 800, y: 460, class: 'advanced'},
            {id: 'flow_network', text: 'üåä Max Flow\nNetwork Flow', x: 900, y: 460, class: 'advanced'},
            {id: 'monotonic_stack', text: 'üìö Monotonic Stack/Deque\nNext Greater', x: 1000, y: 460, class: 'advanced'},
            {id: 'bit_manipulation', text: 'üî¢ Bit Manipulation\nMasks/XOR', x: 1100, y: 460, class: 'advanced'},
            {id: 'game_theory', text: 'üé≤ Game Theory\nNim/Minimax', x: 1200, y: 460, class: 'advanced'},
            
            // Implementation Styles
            {id: 'memoization', text: 'üìù Memoization\nTop-Down', x: 200, y: 530, class: 'implementation'},
            {id: 'tabulation', text: 'üìä Tabulation\nBottom-Up', x: 350, y: 530, class: 'implementation'},
            {id: 'recursive', text: 'üîÑ Recursive', x: 500, y: 530, class: 'implementation'},
            {id: 'iterative', text: 'üîÅ Iterative', x: 650, y: 530, class: 'implementation'},
            {id: 'greedy', text: 'üèÉ Greedy', x: 800, y: 530, class: 'implementation'},
            {id: 'divide_conquer', text: '‚öîÔ∏è Divide & Conquer', x: 950, y: 530, class: 'implementation'},
            {id: 'online_algo', text: 'üì° Online Algorithm', x: 1100, y: 530, class: 'implementation'},
            
            // Real Problem Examples
            {id: 'max_subarray', text: 'Maximum Subarray\nStock Prices', x: 30, y: 600, class: 'example'},
            {id: 'partition_sum', text: 'Partition Equal Sum\nSubset Sum', x: 130, y: 600, class: 'example'},
            {id: 'n_queens', text: 'N-Queens\nSudoku Solver', x: 230, y: 600, class: 'example'},
            {id: 'edit_distance', text: 'Edit Distance\nLCS', x: 330, y: 600, class: 'example'},
            {id: 'word_ladder', text: 'Word Ladder\nMinimum Steps', x: 430, y: 600, class: 'example'},
            {id: 'course_schedule', text: 'Course Schedule\nDetect Cycle', x: 530, y: 600, class: 'example'},
            {id: 'word_search', text: 'Word Search II\nBoggle', x: 630, y: 600, class: 'example'},
            {id: 'merge_intervals', text: 'Merge Intervals\nMeeting Rooms', x: 730, y: 600, class: 'example'},
            {id: 'kth_largest', text: 'Kth Largest\nTop K Elements', x: 830, y: 600, class: 'example'},
            {id: 'search_rotated', text: 'Search Rotated\nFind Peak', x: 930, y: 600, class: 'example'},
            {id: 'three_sum', text: 'Three Sum\nContainer Water', x: 1030, y: 600, class: 'example'},
            {id: 'number_islands', text: 'Number of Islands\nFriend Circles', x: 1130, y: 600, class: 'example'},
            {id: 'lru_cache', text: 'LRU Cache\nDesign DS', x: 1230, y: 600, class: 'example'},
            
            // Meta Skills
            {id: 'time_analysis', text: '‚è∞ Time Complexity\nAnalysis', x: 300, y: 670, class: 'analysis'},
            {id: 'space_optimize', text: 'üíæ Space\nOptimization', x: 450, y: 670, class: 'analysis'},
            {id: 'edge_cases', text: 'üö® Edge Cases\nBoundary Tests', x: 600, y: 670, class: 'analysis'},
            {id: 'follow_up', text: 'üîÑ Follow-up\nVariations', x: 750, y: 670, class: 'analysis'},
            {id: 'scalability', text: 'üìà Scalability\nDistributed', x: 900, y: 670, class: 'analysis'}
        ];

        const edges = [
            // Main analysis flow
            {from: 'start', to: 'read'},
            {from: 'read', to: 'constraints'}, {from: 'read', to: 'examples'}, {from: 'read', to: 'output'}, 
            {from: 'read', to: 'complexity'}, {from: 'read', to: 'data_size'},
            
            // Decision branches
            {from: 'constraints', to: 'optimization'}, {from: 'examples', to: 'search_space'},
            {from: 'output', to: 'data_structure'}, {from: 'complexity', to: 'string_processing'},
            {from: 'data_size', to: 'math_logic'}, {from: 'complexity', to: 'interactive'},
            
            // Pattern recognition
            {from: 'optimization', to: 'subarray_pattern'}, {from: 'optimization', to: 'knapsack_pattern'},
            {from: 'search_space', to: 'backtrack_pattern'}, {from: 'data_structure', to: 'dp_pattern'},
            {from: 'data_structure', to: 'graph_pattern'}, {from: 'string_processing', to: 'trie_pattern'},
            {from: 'math_logic', to: 'heap_pattern'}, {from: 'data_size', to: 'sorted_pattern'},
            {from: 'graph_pattern', to: 'union_find_pattern'},
            
            // Core algorithms
            {from: 'subarray_pattern', to: 'kadane'}, {from: 'subarray_pattern', to: 'sliding_window'},
            {from: 'knapsack_pattern', to: 'knapsack_dp'}, {from: 'backtrack_pattern', to: 'backtracking'},
            {from: 'dp_pattern', to: 'classic_dp'}, {from: 'graph_pattern', to: 'dfs_bfs'},
            {from: 'graph_pattern', to: 'dijkstra'}, {from: 'trie_pattern', to: 'trie_ds'},
            {from: 'trie_pattern', to: 'kmp_algo'}, {from: 'heap_pattern', to: 'heap_ops'},
            {from: 'sorted_pattern', to: 'binary_search'}, {from: 'sorted_pattern', to: 'two_pointer'},
            {from: 'union_find_pattern', to: 'union_find'},
            
            // Advanced techniques
            {from: 'sliding_window', to: 'segment_tree'}, {from: 'classic_dp', to: 'fenwick_tree'},
            {from: 'dfs_bfs', to: 'lca'}, {from: 'dfs_bfs', to: 'topological_sort'},
            {from: 'dijkstra', to: 'strongly_connected'}, {from: 'kmp_algo', to: 'suffix_array'},
            {from: 'heap_ops', to: 'monotonic_stack'}, {from: 'binary_search', to: 'bit_manipulation'},
            {from: 'union_find', to: 'flow_network'},
            
            // Implementation styles
            {from: 'knapsack_dp', to: 'memoization'}, {from: 'knapsack_dp', to: 'tabulation'},
            {from: 'backtracking', to: 'recursive'}, {from: 'dfs_bfs', to: 'iterative'},
            {from: 'heap_ops', to: 'greedy'}, {from: 'binary_search', to: 'divide_conquer'},
            
            // Examples
            {from: 'kadane', to: 'max_subarray'}, {from: 'memoization', to: 'partition_sum'},
            {from: 'backtracking', to: 'n_queens'}, {from: 'classic_dp', to: 'edit_distance'},
            {from: 'dfs_bfs', to: 'word_ladder'}, {from: 'topological_sort', to: 'course_schedule'},
            {from: 'trie_ds', to: 'word_search'}, {from: 'greedy', to: 'merge_intervals'},
            {from: 'heap_ops', to: 'kth_largest'}, {from: 'binary_search', to: 'search_rotated'},
            {from: 'two_pointer', to: 'three_sum'}, {from: 'union_find', to: 'number_islands'},
            {from: 'online_algo', to: 'lru_cache'},
            
            // Meta analysis
            {from: 'iterative', to: 'time_analysis'}, {from: 'tabulation', to: 'space_optimize'},
            {from: 'recursive', to: 'edge_cases'}, {from: 'greedy', to: 'follow_up'},
            {from: 'divide_conquer', to: 'scalability'}
        ];

        const pathHighlights = {
            knapsack: ['start', 'read', 'constraints', 'optimization', 'knapsack_pattern', 'knapsack_dp', 'memoization', 'partition_sum'],
            kadane: ['start', 'read', 'examples', 'optimization', 'subarray_pattern', 'kadane', 'max_subarray'],
            twopointer: ['start', 'read', 'data_size', 'sorted_pattern', 'two_pointer', 'three_sum'],
            backtrack: ['start', 'read', 'examples', 'search_space', 'backtrack_pattern', 'backtracking', 'recursive', 'n_queens'],
            unionfind: ['start', 'read', 'output', 'data_structure', 'graph_pattern', 'union_find_pattern', 'union_find', 'number_islands'],
            trie: ['start', 'read', 'complexity', 'string_processing', 'trie_pattern', 'trie_ds', 'word_search'],
            heap: ['start', 'read', 'complexity', 'math_logic', 'heap_pattern', 'heap_ops', 'greedy', 'kth_largest'],
            binarysearch: ['start', 'read', 'data_size', 'sorted_pattern', 'binary_search', 'divide_conquer', 'search_rotated']
        };

        function createNodes() {
            const graph = document.getElementById('graph');
            
            nodes.forEach(node => {
                const nodeEl = document.createElement('div');
                nodeEl.className = `node ${node.class}`;
                nodeEl.id = node.id;
                nodeEl.textContent = node.text;
                nodeEl.style.left = node.x + 'px';
                nodeEl.style.top = node.y + 'px';
                graph.appendChild(nodeEl);
            });
            
            edges.forEach((edge, index) => {
                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);
                
                if (fromNode && toNode) {
                    const edgeEl = document.createElement('div');
                    edgeEl.className = 'edge';
                    edgeEl.id = `edge-${index}`;
                    
                    const dx = toNode.x - fromNode.x;
                    const dy = toNode.y - fromNode.y;
                    const length = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    edgeEl.style.left = (fromNode.x + 80) + 'px';
                    edgeEl.style.top = (fromNode.y + 15) + 'px';
                    edgeEl.style.width = (length - 80) + 'px';
                    edgeEl.style.transform = `rotate(${angle}deg)`;
                    
                    graph.appendChild(edgeEl);
                    
                    if (edge.label) {
                        const labelEl = document.createElement('div');
                        labelEl.className = 'edge-label';
                        labelEl.textContent = edge.label;
                        labelEl.style.left = (fromNode.x + dx/2) + 'px';
                        labelEl.style.top = (fromNode.y + dy/2) + 'px';
                        graph.appendChild(labelEl);
                    }
                }
            });
        }

        function highlightPath(pathName) {
            clearHighlights();
            const path = pathHighlights[pathName];
            if (path) {
                path.forEach(nodeId => {
                    const node = document.getElementById(nodeId);
                    if (node) {
                        node.classList.add('path-highlight');
                    }
                });
            }
        }

        function clearHighlights() {
            document.querySelectorAll('.path-highlight').forEach(el => {
                el.classList.remove('path-highlight');
            });
        }

        // Initialize
        createNodes();
        
        // Enhanced hover effects
        document.querySelectorAll('.node').forEach(node => {
            node.addEventListener('mouseenter', function() {
                this.style.zIndex = '1000';
            });
            
            node.addEventListener('mouseleave', function() {
                this.style.zIndex = 'auto';
            });
        });
    </script>
</body>
</html>